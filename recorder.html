<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>键盘声音批量录制器</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 1200px;
            width: 100%;
            padding: 40px;
            animation: fadeIn 0.5s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1 {
            text-align: center;
            color: #1e3c72;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 30px;
        }

        .section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
        }

        .section-title {
            font-size: 1.2em;
            color: #333;
            margin-bottom: 15px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .device-selector {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-size: 16px;
            background: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .device-selector:hover {
            border-color: #1e3c72;
        }

        .volume-meter {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 15px;
        }

        .volume-bar {
            flex: 1;
            height: 30px;
            background: #e0e0e0;
            border-radius: 15px;
            overflow: hidden;
            position: relative;
        }

        .volume-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A, #FFC107, #FF5722);
            width: 0%;
            transition: width 0.1s ease;
        }

        .volume-text {
            min-width: 60px;
            text-align: right;
            font-weight: bold;
            color: #666;
        }

        .batch-control {
            display: flex;
            gap: 15px;
            align-items: flex-start;
            margin-bottom: 20px;
        }

        .batch-input {
            flex: 1;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-size: 14px;
            font-family: monospace;
            resize: vertical;
            min-height: 100px;
        }

        .sequence-list {
            max-height: 500px;
            overflow-y: auto;
            background: white;
            border-radius: 10px;
            padding: 15px;
        }

        .sequence-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 15px;
            margin: 5px 0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: monospace;
            font-size: 16px;
        }

        .sequence-item:hover {
            transform: translateX(5px);
        }

        .sequence-item.pending {
            background: #f0f0f0;
            color: #666;
        }

        .sequence-item.current {
            background: #2196F3;
            color: white;
            font-weight: bold;
            box-shadow: 0 3px 10px rgba(33, 150, 243, 0.3);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }

        .sequence-item.completed {
            background: #4CAF50;
            color: white;
        }

        .sequence-item .status {
            font-size: 20px;
        }

        .current-recording {
            text-align: center;
            padding: 30px;
            background: linear-gradient(135deg, #2196F3, #1976D2);
            color: white;
            border-radius: 15px;
            margin-bottom: 20px;
        }

        .current-number {
            font-size: 72px;
            font-weight: bold;
            margin: 10px 0;
            font-family: monospace;
            letter-spacing: 15px;
        }

        .btn {
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #2196F3, #1976D2);
            color: white;
            width: 100%;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(33, 150, 243, 0.4);
        }

        .btn-success {
            background: #4CAF50;
            color: white;
        }

        .btn-danger {
            background: #f44336;
            color: white;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .control-panel {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin: 20px 0;
        }

        .recording-status {
            text-align: center;
            font-size: 20px;
            margin: 20px 0;
            font-weight: 500;
            min-height: 30px;
        }

        .recording-status.ready {
            color: #4CAF50;
        }

        .recording-status.countdown {
            color: #FF9800;
        }

        .recording-status.recording {
            color: #f44336;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .countdown {
            font-size: 120px;
            font-weight: bold;
            color: #FF9800;
            text-align: center;
            margin: 40px 0;
            font-family: monospace;
            text-shadow: 0 5px 20px rgba(255, 152, 0, 0.5);
        }

        .progress-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 20px 0;
            padding: 15px;
            background: #e3f2fd;
            border-radius: 10px;
        }

        .progress-bar {
            width: 100%;
            height: 30px;
            background: #e0e0e0;
            border-radius: 15px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            width: 0%;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }

        .waveform-container {
            width: 100%;
            height: 150px;
            background: #f0f0f0;
            border-radius: 10px;
            margin: 20px 0;
            position: relative;
            overflow: hidden;
        }

        #waveform {
            width: 100%;
            height: 100%;
        }

        .settings-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 20px 0;
        }

        .setting-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .setting-item label {
            flex: 1;
            color: #666;
        }

        .setting-item input[type="number"] {
            width: 80px;
            padding: 8px;
            border: 2px solid #e0e0e0;
            border-radius: 5px;
            text-align: center;
        }

        .tips {
            background: #e3f2fd;
            border-left: 4px solid #2196F3;
            padding: 15px;
            border-radius: 5px;
            color: #333;
            font-size: 14px;
            line-height: 1.6;
            margin-top: 20px;
        }

        .folder-status {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: #e8f5e9;
            border-radius: 8px;
            margin: 10px 0;
            font-size: 14px;
        }

        .folder-status.error {
            background: #ffebee;
            color: #c62828;
        }

        .hidden {
            display: none;
        }

        .shortcuts {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-size: 12px;
            max-width: 200px;
        }

        .shortcuts h4 {
            margin-bottom: 10px;
        }

        .shortcuts div {
            margin: 5px 0;
        }

        .shortcuts kbd {
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .current-number {
                font-size: 48px;
                letter-spacing: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🎹 键盘声音批量录制器</h1>

        <div class="main-content">
            <!-- 左侧主要区域 -->
            <div class="left-panel">
                <!-- 设备选择 -->
                <div class="section">
                    <div class="section-title">
                        <span>🎤</span> 音频设备
                    </div>
                    <select id="deviceSelector" class="device-selector">
                        <option value="">请选择麦克风...</option>
                    </select>
                    <div class="volume-meter">
                        <span>音量：</span>
                        <div class="volume-bar">
                            <div class="volume-fill" id="volumeFill"></div>
                        </div>
                        <span class="volume-text" id="volumeText">0%</span>
                    </div>
                </div>

                <!-- 当前录制 -->
                <div class="section">
                    <div class="current-recording">
                        <div style="font-size: 18px;">当前录制序列</div>
                        <div class="current-number" id="currentNumber">---</div>
                        <div id="recordingTimer" style="font-size: 24px; margin-top: 10px;">准备就绪</div>
                    </div>
                    <div class="countdown hidden" id="countdown">3</div>
                    
                    <div class="recording-status ready" id="recordingStatus">
                        点击下方按钮开始录制
                    </div>

                    <button id="recordBtn" class="btn btn-primary">
                        <span>🎙️</span> 录制当前序列
                    </button>
                </div>

                <!-- 进度信息 -->
                <div class="progress-info">
                    <span>总进度：<strong id="completedCount">0</strong> / <strong id="totalCount">0</strong></span>
                    <span>完成率：<strong id="completionRate">0%</strong></span>
                </div>

                <!-- 进度条 -->
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>

                <!-- 波形显示 -->
                <div class="section">
                    <div class="section-title">
                        <span>📊</span> 音频波形
                    </div>
                    <div class="waveform-container">
                        <canvas id="waveform"></canvas>
                    </div>
                </div>

                <!-- 设置 -->
                <div class="section">
                    <div class="section-title">
                        <span>⚙️</span> 录制设置
                    </div>
                    <div class="settings-panel">
                        <div class="setting-item">
                            <label>录制前倒计时（秒）：</label>
                            <input type="number" id="countdownTime" value="3" min="0" max="10">
                        </div>
                        <div class="setting-item">
                            <label>录制时长（秒）：</label>
                            <input type="number" id="recordingDuration" value="5" min="1" max="30">
                        </div>
                    </div>
                </div>

                <!-- 文件夹选择 -->
                <div class="section">
                    <div class="section-title">
                        <span>📁</span> 保存设置
                    </div>
                    <button id="selectFolderBtn" class="btn btn-secondary" style="width: 100%;">
                        选择保存文件夹
                    </button>
                    <div id="folderStatus" class="folder-status hidden">
                        <span id="folderPath">未选择文件夹</span>
                    </div>
                </div>
            </div>

            <!-- 右侧序列列表 -->
            <div class="right-panel">
                <div class="section" style="height: calc(100vh - 200px); display: flex; flex-direction: column;">
                    <div class="section-title">
                        <span>📝</span> 录制序列
                    </div>
                    
                    <!-- 批量输入 -->
                    <div class="batch-control">
                        <textarea id="batchInput" class="batch-input" rows="4" 
                                placeholder="输入要录制的序列，每行一个：&#10;123456&#10;789012&#10;345678"></textarea>
                        <button id="loadSequencesBtn" class="btn btn-secondary">加载序列</button>
                    </div>

                    <!-- 序列列表 -->
                    <div class="sequence-list" id="sequenceList">
                        <!-- 序列项将动态添加到这里 -->
                    </div>

                    <div style="margin-top: 10px; padding: 10px; background: #f0f0f0; border-radius: 8px; text-align: center;">
                        <small>点击序列可切换到该项进行录制</small>
                    </div>
                </div>
            </div>
        </div>

        <!-- 使用提示 -->
        <div class="tips">
            <strong>💡 使用提示：</strong><br>
            1. <strong>准备序列</strong>：在右侧输入要录制的数字序列，每行一个<br>
            2. <strong>选择录制项</strong>：点击序列列表中的项目选中要录制的序列<br>
            3. <strong>开始录制</strong>：点击"录制当前序列"按钮，倒计时后开始录音<br>
            4. <strong>自动保存</strong>：录制完成后自动保存为WAV格式<br>
            5. <strong>继续下一个</strong>：手动选择下一个序列继续录制
        </div>
    </div>

    <!-- 快捷键提示 -->
    <div class="shortcuts">
        <h4>快捷键</h4>
        <div><kbd>Enter</kbd> 录制当前</div>
        <div><kbd>↑/↓</kbd> 切换序列</div>
        <div><kbd>R</kbd> 重录当前</div>
    </div>

    <script>
        // 全局变量
        let mediaRecorder = null;
        let audioContext = null;
        let audioChunks = [];
        let isRecording = false;
        let selectedDeviceId = null;
        let sequences = [];
        let currentIndex = -1;
        let recordingStartTime = null;
        let recordingInterval = null;
        let countdownInterval = null;
        let volumeMonitorInterval = null;
        let directoryHandle = null;
        let stream = null;

        // 配置
        const config = {
            countdownTime: 3,
            recordingDuration: 5,
            sampleRate: 44100
        };

        // 初始化
        window.addEventListener('DOMContentLoaded', async () => {
            // 检查浏览器支持
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                alert('您的浏览器不支持录音功能');
                return;
            }

            // 初始化音频上下文
            audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: config.sampleRate });

            // 获取设备列表
            await getAudioDevices();

            // 绑定事件
            bindEvents();

            // 加载配置
            loadConfig();

            // 加载示例序列
            document.getElementById('batchInput').value = '123456\n654321\n111111\n222222\n333333';
            loadSequences();
        });

        // 绑定事件
        function bindEvents() {
            // 设备选择
            document.getElementById('deviceSelector').addEventListener('change', onDeviceChange);

            // 录制按钮
            document.getElementById('recordBtn').addEventListener('click', handleRecord);

            // 序列管理
            document.getElementById('loadSequencesBtn').addEventListener('click', loadSequences);

            // 文件夹选择
            document.getElementById('selectFolderBtn').addEventListener('click', selectFolder);

            // 设置变更
            document.getElementById('countdownTime').addEventListener('change', updateConfig);
            document.getElementById('recordingDuration').addEventListener('change', updateConfig);

            // 快捷键
            document.addEventListener('keydown', handleKeyPress);
        }

        // 获取音频设备
        async function getAudioDevices() {
            try {
                // 请求权限
                const tempStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                tempStream.getTracks().forEach(track => track.stop());

                // 获取设备列表
                const devices = await navigator.mediaDevices.enumerateDevices();
                const audioInputs = devices.filter(device => device.kind === 'audioinput');

                const selector = document.getElementById('deviceSelector');
                selector.innerHTML = '<option value="">请选择麦克风...</option>';

                audioInputs.forEach((device, index) => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.text = device.label || `麦克风 ${index + 1}`;
                    selector.appendChild(option);
                });

                if (audioInputs.length > 0) {
                    selector.value = audioInputs[0].deviceId;
                    selectedDeviceId = audioInputs[0].deviceId;
                    startVolumeMonitor();
                }
            } catch (error) {
                console.error('获取音频设备失败:', error);
                alert('无法获取麦克风权限');
            }
        }

        // 设备改变
        function onDeviceChange(e) {
            selectedDeviceId = e.target.value;
            if (selectedDeviceId) {
                startVolumeMonitor();
            }
        }

        // 音量监控
        async function startVolumeMonitor() {
            if (volumeMonitorInterval) {
                clearInterval(volumeMonitorInterval);
            }

            if (!selectedDeviceId) return;

            try {
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                }

                stream = await navigator.mediaDevices.getUserMedia({
                    audio: { deviceId: selectedDeviceId }
                });

                const source = audioContext.createMediaStreamSource(stream);
                const analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                source.connect(analyser);

                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);

                volumeMonitorInterval = setInterval(() => {
                    analyser.getByteFrequencyData(dataArray);
                    const average = dataArray.reduce((a, b) => a + b) / bufferLength;
                    const volume = Math.min(100, Math.round((average / 255) * 100 * 2));
                    
                    document.getElementById('volumeFill').style.width = volume + '%';
                    document.getElementById('volumeText').textContent = volume + '%';
                }, 100);
            } catch (error) {
                console.error('音量监控失败:', error);
            }
        }

        // 加载序列
        function loadSequences() {
            const input = document.getElementById('batchInput').value;
            sequences = input.split('\n')
                .map(s => s.trim())
                .filter(s => s && /^\d+$/.test(s));

            if (sequences.length === 0) {
                alert('请输入有效的数字序列');
                return;
            }

            currentIndex = 0;
            updateSequenceList();
            updateProgress();
        }

        // 更新序列列表显示
        function updateSequenceList() {
            const listEl = document.getElementById('sequenceList');
            listEl.innerHTML = '';

            sequences.forEach((seq, index) => {
                const item = document.createElement('div');
                item.className = 'sequence-item';
                
                // 根据状态设置样式
                if (index === currentIndex) {
                    item.classList.add('current');
                } else if (localStorage.getItem(`recorded_${seq}`) === 'true') {
                    item.classList.add('completed');
                } else {
                    item.classList.add('pending');
                }

                item.dataset.index = index;
                
                const status = localStorage.getItem(`recorded_${seq}`) === 'true' ? '✅' : '⏳';
                
                item.innerHTML = `
                    <span style="font-size: 20px; font-weight: bold;">${seq}</span>
                    <span class="status">${status}</span>
                `;
                
                item.addEventListener('click', () => selectSequence(index));
                listEl.appendChild(item);
            });

            // 更新当前显示
            if (currentIndex >= 0 && currentIndex < sequences.length) {
                document.getElementById('currentNumber').textContent = sequences[currentIndex];
            } else {
                document.getElementById('currentNumber').textContent = '---';
            }

            // 滚动到当前项
            const currentItem = listEl.querySelector('.current');
            if (currentItem) {
                currentItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        // 选择序列
        function selectSequence(index) {
            if (isRecording) {
                alert('请先停止当前录制');
                return;
            }

            currentIndex = index;
            updateSequenceList();
            document.getElementById('recordingStatus').textContent = '点击按钮开始录制';
            document.getElementById('recordingStatus').className = 'recording-status ready';
        }

        // 更新进度
        function updateProgress() {
            const completed = sequences.filter(seq => 
                localStorage.getItem(`recorded_${seq}`) === 'true'
            ).length;
            
            const total = sequences.length;
            const progress = total > 0 ? (completed / total) * 100 : 0;
            
            document.getElementById('completedCount').textContent = completed;
            document.getElementById('totalCount').textContent = total;
            document.getElementById('completionRate').textContent = Math.round(progress) + '%';
            
            document.getElementById('progressFill').style.width = progress + '%';
            document.getElementById('progressFill').textContent = `${completed} / ${total}`;
        }

        // 处理录制
        async function handleRecord() {
            if (currentIndex < 0 || currentIndex >= sequences.length) {
                alert('请先选择要录制的序列');
                return;
            }

            if (!selectedDeviceId) {
                alert('请先选择麦克风设备');
                return;
            }

            if (isRecording) {
                return;
            }

            // 禁用按钮
            document.getElementById('recordBtn').disabled = true;
            document.getElementById('recordBtn').textContent = '准备中...';

            // 倒计时
            if (config.countdownTime > 0) {
                await countdown(config.countdownTime);
            }

            // 开始录制
            startRecording(sequences[currentIndex]);
        }

        // 倒计时
        function countdown(seconds) {
            return new Promise(resolve => {
                let remaining = seconds;
                const countdownEl = document.getElementById('countdown');
                const statusEl = document.getElementById('recordingStatus');
                
                countdownEl.classList.remove('hidden');
                countdownEl.textContent = remaining;
                statusEl.textContent = `准备录制，倒计时 ${remaining} 秒...`;
                statusEl.className = 'recording-status countdown';

                countdownInterval = setInterval(() => {
                    remaining--;
                    if (remaining > 0) {
                        countdownEl.textContent = remaining;
                        statusEl.textContent = `准备录制，倒计时 ${remaining} 秒...`;
                    } else {
                        clearInterval(countdownInterval);
                        countdownEl.classList.add('hidden');
                        resolve();
                    }
                }, 1000);
            });
        }

        // 开始录制
        async function startRecording(sequence) {
            try {
                // 创建新的流
                const recordStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        deviceId: selectedDeviceId,
                        sampleRate: config.sampleRate,
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    }
                });

                // 创建 MediaRecorder
                mediaRecorder = new MediaRecorder(recordStream, {
                    mimeType: 'audio/webm'
                });

                audioChunks = [];
                isRecording = true;
                recordingStartTime = Date.now();

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = async () => {
                    isRecording = false;
                    recordStream.getTracks().forEach(track => track.stop());

                    // 处理录音
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    await processAndSave(audioBlob, sequence);

                    // 标记完成
                    localStorage.setItem(`recorded_${sequence}`, 'true');
                    updateSequenceList();
                    updateProgress();

                    // 恢复UI
                    document.getElementById('recordBtn').disabled = false;
                    document.getElementById('recordBtn').innerHTML = '<span>🎙️</span> 录制当前序列';
                    document.getElementById('recordingStatus').textContent = '录制完成！选择下一个序列继续';
                    document.getElementById('recordingStatus').className = 'recording-status ready';
                    document.getElementById('recordingTimer').textContent = '准备就绪';

                    // 自动选择下一个未录制的
                    autoSelectNext();
                };

                // 开始录音
                mediaRecorder.start();

                // 更新UI
                document.getElementById('recordBtn').innerHTML = '<span>🔴</span> 录制中...';
                document.getElementById('recordingStatus').textContent = '正在录制，请敲击键盘...';
                document.getElementById('recordingStatus').className = 'recording-status recording';

                // 更新计时器
                recordingInterval = setInterval(() => {
                    const elapsed = (Date.now() - recordingStartTime) / 1000;
                    document.getElementById('recordingTimer').textContent = `录制中：${elapsed.toFixed(1)} / ${config.recordingDuration} 秒`;
                }, 100);

                // 实时波形
                visualizeAudio(recordStream);

                // 自动停止
                setTimeout(() => {
                    if (isRecording && mediaRecorder.state === 'recording') {
                        clearInterval(recordingInterval);
                        mediaRecorder.stop();
                    }
                }, config.recordingDuration * 1000);

            } catch (error) {
                console.error('录音失败:', error);
                alert('录音失败：' + error.message);
                
                // 恢复UI
                document.getElementById('recordBtn').disabled = false;
                document.getElementById('recordBtn').innerHTML = '<span>🎙️</span> 录制当前序列';
                document.getElementById('recordingStatus').textContent = '录音失败，请重试';
                document.getElementById('recordingStatus').className = 'recording-status ready';
            }
        }

        // 自动选择下一个未录制的序列
        function autoSelectNext() {
            // 查找下一个未录制的序列
            for (let i = currentIndex + 1; i < sequences.length; i++) {
                if (localStorage.getItem(`recorded_${sequences[i]}`) !== 'true') {
                    currentIndex = i;
                    updateSequenceList();
                    return;
                }
            }

            // 如果后面没有，从头查找
            for (let i = 0; i < currentIndex; i++) {
                if (localStorage.getItem(`recorded_${sequences[i]}`) !== 'true') {
                    currentIndex = i;
                    updateSequenceList();
                    return;
                }
            }

            // 如果全部完成
            if (sequences.every(seq => localStorage.getItem(`recorded_${seq}`) === 'true')) {
                alert('恭喜！所有序列录制完成！');
            }
        }

        // 处理并保存录音
        async function processAndSave(blob, sequence) {
            try {
                // 转换为WAV格式
                const wavBlob = await convertToWav(blob);

                // 保存文件
                if (directoryHandle) {
                    // 使用File System Access API
                    await saveToDirectory(wavBlob, `${sequence}.wav`);
                } else {
                    // 降级为下载
                    downloadFile(wavBlob, `${sequence}.wav`);
                }

                // 绘制波形
                await drawWaveform(wavBlob);

            } catch (error) {
                console.error('处理录音失败:', error);
                alert('处理录音失败，请重试');
                // 移除已完成标记
                localStorage.removeItem(`recorded_${sequence}`);
            }
        }

        // 转换为WAV格式
        async function convertToWav(webmBlob) {
            const arrayBuffer = await webmBlob.arrayBuffer();
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

            // 转换为单声道
            const numberOfChannels = 1;
            const length = audioBuffer.length;
            const sampleRate = audioBuffer.sampleRate;
            const bitsPerSample = 16;
            const bytesPerSample = bitsPerSample / 8;
            const blockAlign = numberOfChannels * bytesPerSample;
            const byteRate = sampleRate * blockAlign;
            const dataSize = length * blockAlign;
            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);

            // WAV文件头
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };

            writeString(0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numberOfChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitsPerSample, true);
            writeString(36, 'data');
            view.setUint32(40, dataSize, true);

            // 获取音频数据（混合多声道为单声道）
            let channelData;
            if (audioBuffer.numberOfChannels > 1) {
                channelData = new Float32Array(length);
                for (let i = 0; i < length; i++) {
                    let sum = 0;
                    for (let channel = 0; channel < audioBuffer.numberOfChannels; channel++) {
                        sum += audioBuffer.getChannelData(channel)[i];
                    }
                    channelData[i] = sum / audioBuffer.numberOfChannels;
                }
            } else {
                channelData = audioBuffer.getChannelData(0);
            }

            // 写入音频数据
            const offset = 44;
            for (let i = 0; i < length; i++) {
                const sample = Math.max(-1, Math.min(1, channelData[i]));
                const value = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                view.setInt16(offset + i * bytesPerSample, value, true);
            }

            return new Blob([buffer], { type: 'audio/wav' });
        }

        // 保存到目录
        async function saveToDirectory(blob, filename) {
            try {
                const fileHandle = await directoryHandle.getFileHandle(filename, { create: true });
                const writable = await fileHandle.createWritable();
                await writable.write(blob);
                await writable.close();
                console.log(`已保存: ${filename}`);
            } catch (error) {
                console.error('保存失败:', error);
                // 降级为下载
                downloadFile(blob, filename);
            }
        }

        // 下载文件
        function downloadFile(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        // 选择文件夹
        async function selectFolder() {
            if ('showDirectoryPicker' in window) {
                try {
                    directoryHandle = await window.showDirectoryPicker();
                    document.getElementById('folderStatus').classList.remove('hidden', 'error');
                    document.getElementById('folderPath').textContent = `已选择文件夹: ${directoryHandle.name}`;
                } catch (error) {
                    console.error('选择文件夹失败:', error);
                }
            } else {
                document.getElementById('folderStatus').classList.remove('hidden');
                document.getElementById('folderStatus').classList.add('error');
                document.getElementById('folderPath').textContent = '浏览器不支持文件夹选择，将通过下载保存';
            }
        }

        // 可视化音频
        function visualizeAudio(stream) {
            const canvas = document.getElementById('waveform');
            const canvasCtx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            const source = audioContext.createMediaStreamSource(stream);
            const analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048;
            source.connect(analyser);

            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);

            function draw() {
                if (!isRecording) return;

                requestAnimationFrame(draw);

                analyser.getByteTimeDomainData(dataArray);

                canvasCtx.fillStyle = '#f0f0f0';
                canvasCtx.fillRect(0, 0, canvas.width, canvas.height);

                canvasCtx.lineWidth = 2;
                canvasCtx.strokeStyle = '#2196F3';
                canvasCtx.beginPath();

                const sliceWidth = canvas.width / bufferLength;
                let x = 0;

                for (let i = 0; i < bufferLength; i++) {
                    const v = dataArray[i] / 128.0;
                    const y = v * canvas.height / 2;

                    if (i === 0) {
                        canvasCtx.moveTo(x, y);
                    } else {
                        canvasCtx.lineTo(x, y);
                    }

                    x += sliceWidth;
                }

                canvasCtx.lineTo(canvas.width, canvas.height / 2);
                canvasCtx.stroke();
            }

            draw();
        }

        // 绘制完整波形
        async function drawWaveform(blob) {
            const arrayBuffer = await blob.arrayBuffer();
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            
            const canvas = document.getElementById('waveform');
            const canvasCtx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            const data = audioBuffer.getChannelData(0);
            const step = Math.ceil(data.length / canvas.width);
            const amp = canvas.height / 2;

            canvasCtx.fillStyle = '#f0f0f0';
            canvasCtx.fillRect(0, 0, canvas.width, canvas.height);

            canvasCtx.strokeStyle = '#4CAF50';
            canvasCtx.lineWidth = 1;

            for (let i = 0; i < canvas.width; i++) {
                let min = 1.0;
                let max = -1.0;

                for (let j = 0; j < step; j++) {
                    const datum = data[(i * step) + j];
                    if (datum < min) min = datum;
                    if (datum > max) max = datum;
                }

                const yLow = (1 + min) * amp;
                const yHigh = (1 + max) * amp;

                canvasCtx.beginPath();
                canvasCtx.moveTo(i, yLow);
                canvasCtx.lineTo(i, yHigh);
                canvasCtx.stroke();
            }
        }

        // 更新配置
        function updateConfig() {
            config.countdownTime = parseInt(document.getElementById('countdownTime').value);
            config.recordingDuration = parseInt(document.getElementById('recordingDuration').value);
            
            // 保存到本地存储
            localStorage.setItem('recorderConfig', JSON.stringify(config));
        }

        // 加载配置
        function loadConfig() {
            const saved = localStorage.getItem('recorderConfig');
            if (saved) {
                const savedConfig = JSON.parse(saved);
                Object.assign(config, savedConfig);
                
                document.getElementById('countdownTime').value = config.countdownTime;
                document.getElementById('recordingDuration').value = config.recordingDuration;
            }
        }

        // 快捷键处理
        function handleKeyPress(e) {
            if (isRecording) return;

            switch(e.key) {
                case 'Enter':
                    e.preventDefault();
                    if (!document.getElementById('recordBtn').disabled) {
                        handleRecord();
                    }
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    if (currentIndex < sequences.length - 1) {
                        selectSequence(currentIndex + 1);
                    }
                    break;
                case 'ArrowUp':
                    e.preventDefault();
                    if (currentIndex > 0) {
                        selectSequence(currentIndex - 1);
                    }
                    break;
                case 'r':
                case 'R':
                    e.preventDefault();
                    if (currentIndex >= 0 && currentIndex < sequences.length) {
                        // 清除当前序列的已录制状态
                        localStorage.removeItem(`recorded_${sequences[currentIndex]}`);
                        updateSequenceList();
                        updateProgress();
                    }
                    break;
            }
        }
    </script>
</body>
</html>