<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é”®ç›˜å£°éŸ³æ‰¹é‡å½•åˆ¶å™¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 1200px;
            width: 100%;
            padding: 40px;
            animation: fadeIn 0.5s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1 {
            text-align: center;
            color: #1e3c72;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 30px;
        }

        .section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
        }

        .section-title {
            font-size: 1.2em;
            color: #333;
            margin-bottom: 15px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .device-selector {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-size: 16px;
            background: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .device-selector:hover {
            border-color: #1e3c72;
        }

        .volume-meter {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 15px;
        }

        .volume-bar {
            flex: 1;
            height: 30px;
            background: #e0e0e0;
            border-radius: 15px;
            overflow: hidden;
            position: relative;
        }

        .volume-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A, #FFC107, #FF5722);
            width: 0%;
            transition: width 0.1s ease;
        }

        .volume-text {
            min-width: 60px;
            text-align: right;
            font-weight: bold;
            color: #666;
        }

        .batch-control {
            display: flex;
            gap: 15px;
            align-items: flex-start;
            margin-bottom: 20px;
        }

        .batch-input {
            flex: 1;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-size: 14px;
            font-family: monospace;
            resize: vertical;
            min-height: 100px;
        }

        .sequence-list {
            max-height: 500px;
            overflow-y: auto;
            background: white;
            border-radius: 10px;
            padding: 15px;
        }

        .sequence-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 15px;
            margin: 5px 0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: monospace;
            font-size: 16px;
        }

        .sequence-item:hover {
            transform: translateX(5px);
        }

        .sequence-item.pending {
            background: #f0f0f0;
            color: #666;
        }

        .sequence-item.current {
            background: #2196F3;
            color: white;
            font-weight: bold;
            box-shadow: 0 3px 10px rgba(33, 150, 243, 0.3);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }

        .sequence-item.completed {
            background: #4CAF50;
            color: white;
        }

        .sequence-item .status {
            font-size: 20px;
        }

        .current-recording {
            text-align: center;
            padding: 30px;
            background: linear-gradient(135deg, #2196F3, #1976D2);
            color: white;
            border-radius: 15px;
            margin-bottom: 20px;
        }

        .current-number {
            font-size: 72px;
            font-weight: bold;
            margin: 10px 0;
            font-family: monospace;
            letter-spacing: 15px;
        }

        .btn {
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #2196F3, #1976D2);
            color: white;
            width: 100%;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(33, 150, 243, 0.4);
        }

        .btn-success {
            background: #4CAF50;
            color: white;
        }

        .btn-danger {
            background: #f44336;
            color: white;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .control-panel {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin: 20px 0;
        }

        .recording-status {
            text-align: center;
            font-size: 20px;
            margin: 20px 0;
            font-weight: 500;
            min-height: 30px;
        }

        .recording-status.ready {
            color: #4CAF50;
        }

        .recording-status.countdown {
            color: #FF9800;
        }

        .recording-status.recording {
            color: #f44336;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .countdown {
            font-size: 120px;
            font-weight: bold;
            color: #FF9800;
            text-align: center;
            margin: 40px 0;
            font-family: monospace;
            text-shadow: 0 5px 20px rgba(255, 152, 0, 0.5);
        }

        .progress-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 20px 0;
            padding: 15px;
            background: #e3f2fd;
            border-radius: 10px;
        }

        .progress-bar {
            width: 100%;
            height: 30px;
            background: #e0e0e0;
            border-radius: 15px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            width: 0%;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }

        .waveform-container {
            width: 100%;
            height: 150px;
            background: #f0f0f0;
            border-radius: 10px;
            margin: 20px 0;
            position: relative;
            overflow: hidden;
        }

        #waveform {
            width: 100%;
            height: 100%;
        }

        .settings-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 20px 0;
        }

        .setting-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .setting-item label {
            flex: 1;
            color: #666;
        }

        .setting-item input[type="number"] {
            width: 80px;
            padding: 8px;
            border: 2px solid #e0e0e0;
            border-radius: 5px;
            text-align: center;
        }

        .tips {
            background: #e3f2fd;
            border-left: 4px solid #2196F3;
            padding: 15px;
            border-radius: 5px;
            color: #333;
            font-size: 14px;
            line-height: 1.6;
            margin-top: 20px;
        }

        .folder-status {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: #e8f5e9;
            border-radius: 8px;
            margin: 10px 0;
            font-size: 14px;
        }

        .folder-status.error {
            background: #ffebee;
            color: #c62828;
        }

        .hidden {
            display: none;
        }

        .shortcuts {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-size: 12px;
            max-width: 200px;
        }

        .shortcuts h4 {
            margin-bottom: 10px;
        }

        .shortcuts div {
            margin: 5px 0;
        }

        .shortcuts kbd {
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .current-number {
                font-size: 48px;
                letter-spacing: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¹ é”®ç›˜å£°éŸ³æ‰¹é‡å½•åˆ¶å™¨</h1>

        <div class="main-content">
            <!-- å·¦ä¾§ä¸»è¦åŒºåŸŸ -->
            <div class="left-panel">
                <!-- è®¾å¤‡é€‰æ‹© -->
                <div class="section">
                    <div class="section-title">
                        <span>ğŸ¤</span> éŸ³é¢‘è®¾å¤‡
                    </div>
                    <select id="deviceSelector" class="device-selector">
                        <option value="">è¯·é€‰æ‹©éº¦å…‹é£...</option>
                    </select>
                    <div class="volume-meter">
                        <span>éŸ³é‡ï¼š</span>
                        <div class="volume-bar">
                            <div class="volume-fill" id="volumeFill"></div>
                        </div>
                        <span class="volume-text" id="volumeText">0%</span>
                    </div>
                </div>

                <!-- å½“å‰å½•åˆ¶ -->
                <div class="section">
                    <div class="current-recording">
                        <div style="font-size: 18px;">å½“å‰å½•åˆ¶åºåˆ—</div>
                        <div class="current-number" id="currentNumber">---</div>
                        <div id="recordingTimer" style="font-size: 24px; margin-top: 10px;">å‡†å¤‡å°±ç»ª</div>
                    </div>
                    <div class="countdown hidden" id="countdown">3</div>
                    
                    <div class="recording-status ready" id="recordingStatus">
                        ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®å¼€å§‹å½•åˆ¶
                    </div>

                    <button id="recordBtn" class="btn btn-primary">
                        <span>ğŸ™ï¸</span> å½•åˆ¶å½“å‰åºåˆ—
                    </button>
                </div>

                <!-- è¿›åº¦ä¿¡æ¯ -->
                <div class="progress-info">
                    <span>æ€»è¿›åº¦ï¼š<strong id="completedCount">0</strong> / <strong id="totalCount">0</strong></span>
                    <span>å®Œæˆç‡ï¼š<strong id="completionRate">0%</strong></span>
                </div>

                <!-- è¿›åº¦æ¡ -->
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>

                <!-- æ³¢å½¢æ˜¾ç¤º -->
                <div class="section">
                    <div class="section-title">
                        <span>ğŸ“Š</span> éŸ³é¢‘æ³¢å½¢
                    </div>
                    <div class="waveform-container">
                        <canvas id="waveform"></canvas>
                    </div>
                </div>

                <!-- è®¾ç½® -->
                <div class="section">
                    <div class="section-title">
                        <span>âš™ï¸</span> å½•åˆ¶è®¾ç½®
                    </div>
                    <div class="settings-panel">
                        <div class="setting-item">
                            <label>å½•åˆ¶å‰å€’è®¡æ—¶ï¼ˆç§’ï¼‰ï¼š</label>
                            <input type="number" id="countdownTime" value="3" min="0" max="10">
                        </div>
                        <div class="setting-item">
                            <label>å½•åˆ¶æ—¶é•¿ï¼ˆç§’ï¼‰ï¼š</label>
                            <input type="number" id="recordingDuration" value="5" min="1" max="30">
                        </div>
                    </div>
                </div>

                <!-- æ–‡ä»¶å¤¹é€‰æ‹© -->
                <div class="section">
                    <div class="section-title">
                        <span>ğŸ“</span> ä¿å­˜è®¾ç½®
                    </div>
                    <button id="selectFolderBtn" class="btn btn-secondary" style="width: 100%;">
                        é€‰æ‹©ä¿å­˜æ–‡ä»¶å¤¹
                    </button>
                    <div id="folderStatus" class="folder-status hidden">
                        <span id="folderPath">æœªé€‰æ‹©æ–‡ä»¶å¤¹</span>
                    </div>
                </div>
            </div>

            <!-- å³ä¾§åºåˆ—åˆ—è¡¨ -->
            <div class="right-panel">
                <div class="section" style="height: calc(100vh - 200px); display: flex; flex-direction: column;">
                    <div class="section-title">
                        <span>ğŸ“</span> å½•åˆ¶åºåˆ—
                    </div>
                    
                    <!-- æ‰¹é‡è¾“å…¥ -->
                    <div class="batch-control">
                        <textarea id="batchInput" class="batch-input" rows="4" 
                                placeholder="è¾“å…¥è¦å½•åˆ¶çš„åºåˆ—ï¼Œæ¯è¡Œä¸€ä¸ªï¼š&#10;123456&#10;789012&#10;345678"></textarea>
                        <button id="loadSequencesBtn" class="btn btn-secondary">åŠ è½½åºåˆ—</button>
                    </div>

                    <!-- åºåˆ—åˆ—è¡¨ -->
                    <div class="sequence-list" id="sequenceList">
                        <!-- åºåˆ—é¡¹å°†åŠ¨æ€æ·»åŠ åˆ°è¿™é‡Œ -->
                    </div>

                    <div style="margin-top: 10px; padding: 10px; background: #f0f0f0; border-radius: 8px; text-align: center;">
                        <small>ç‚¹å‡»åºåˆ—å¯åˆ‡æ¢åˆ°è¯¥é¡¹è¿›è¡Œå½•åˆ¶</small>
                    </div>
                </div>
            </div>
        </div>

        <!-- ä½¿ç”¨æç¤º -->
        <div class="tips">
            <strong>ğŸ’¡ ä½¿ç”¨æç¤ºï¼š</strong><br>
            1. <strong>å‡†å¤‡åºåˆ—</strong>ï¼šåœ¨å³ä¾§è¾“å…¥è¦å½•åˆ¶çš„æ•°å­—åºåˆ—ï¼Œæ¯è¡Œä¸€ä¸ª<br>
            2. <strong>é€‰æ‹©å½•åˆ¶é¡¹</strong>ï¼šç‚¹å‡»åºåˆ—åˆ—è¡¨ä¸­çš„é¡¹ç›®é€‰ä¸­è¦å½•åˆ¶çš„åºåˆ—<br>
            3. <strong>å¼€å§‹å½•åˆ¶</strong>ï¼šç‚¹å‡»"å½•åˆ¶å½“å‰åºåˆ—"æŒ‰é’®ï¼Œå€’è®¡æ—¶åå¼€å§‹å½•éŸ³<br>
            4. <strong>è‡ªåŠ¨ä¿å­˜</strong>ï¼šå½•åˆ¶å®Œæˆåè‡ªåŠ¨ä¿å­˜ä¸ºWAVæ ¼å¼<br>
            5. <strong>ç»§ç»­ä¸‹ä¸€ä¸ª</strong>ï¼šæ‰‹åŠ¨é€‰æ‹©ä¸‹ä¸€ä¸ªåºåˆ—ç»§ç»­å½•åˆ¶
        </div>
    </div>

    <!-- å¿«æ·é”®æç¤º -->
    <div class="shortcuts">
        <h4>å¿«æ·é”®</h4>
        <div><kbd>Enter</kbd> å½•åˆ¶å½“å‰</div>
        <div><kbd>â†‘/â†“</kbd> åˆ‡æ¢åºåˆ—</div>
        <div><kbd>R</kbd> é‡å½•å½“å‰</div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let mediaRecorder = null;
        let audioContext = null;
        let audioChunks = [];
        let isRecording = false;
        let selectedDeviceId = null;
        let sequences = [];
        let currentIndex = -1;
        let recordingStartTime = null;
        let recordingInterval = null;
        let countdownInterval = null;
        let volumeMonitorInterval = null;
        let directoryHandle = null;
        let stream = null;

        // é…ç½®
        const config = {
            countdownTime: 3,
            recordingDuration: 5,
            sampleRate: 44100
        };

        // åˆå§‹åŒ–
        window.addEventListener('DOMContentLoaded', async () => {
            // æ£€æŸ¥æµè§ˆå™¨æ”¯æŒ
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                alert('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒå½•éŸ³åŠŸèƒ½');
                return;
            }

            // åˆå§‹åŒ–éŸ³é¢‘ä¸Šä¸‹æ–‡
            audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: config.sampleRate });

            // è·å–è®¾å¤‡åˆ—è¡¨
            await getAudioDevices();

            // ç»‘å®šäº‹ä»¶
            bindEvents();

            // åŠ è½½é…ç½®
            loadConfig();

            // åŠ è½½ç¤ºä¾‹åºåˆ—
            document.getElementById('batchInput').value = '123456\n654321\n111111\n222222\n333333';
            loadSequences();
        });

        // ç»‘å®šäº‹ä»¶
        function bindEvents() {
            // è®¾å¤‡é€‰æ‹©
            document.getElementById('deviceSelector').addEventListener('change', onDeviceChange);

            // å½•åˆ¶æŒ‰é’®
            document.getElementById('recordBtn').addEventListener('click', handleRecord);

            // åºåˆ—ç®¡ç†
            document.getElementById('loadSequencesBtn').addEventListener('click', loadSequences);

            // æ–‡ä»¶å¤¹é€‰æ‹©
            document.getElementById('selectFolderBtn').addEventListener('click', selectFolder);

            // è®¾ç½®å˜æ›´
            document.getElementById('countdownTime').addEventListener('change', updateConfig);
            document.getElementById('recordingDuration').addEventListener('change', updateConfig);

            // å¿«æ·é”®
            document.addEventListener('keydown', handleKeyPress);
        }

        // è·å–éŸ³é¢‘è®¾å¤‡
        async function getAudioDevices() {
            try {
                // è¯·æ±‚æƒé™
                const tempStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                tempStream.getTracks().forEach(track => track.stop());

                // è·å–è®¾å¤‡åˆ—è¡¨
                const devices = await navigator.mediaDevices.enumerateDevices();
                const audioInputs = devices.filter(device => device.kind === 'audioinput');

                const selector = document.getElementById('deviceSelector');
                selector.innerHTML = '<option value="">è¯·é€‰æ‹©éº¦å…‹é£...</option>';

                audioInputs.forEach((device, index) => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.text = device.label || `éº¦å…‹é£ ${index + 1}`;
                    selector.appendChild(option);
                });

                if (audioInputs.length > 0) {
                    selector.value = audioInputs[0].deviceId;
                    selectedDeviceId = audioInputs[0].deviceId;
                    startVolumeMonitor();
                }
            } catch (error) {
                console.error('è·å–éŸ³é¢‘è®¾å¤‡å¤±è´¥:', error);
                alert('æ— æ³•è·å–éº¦å…‹é£æƒé™');
            }
        }

        // è®¾å¤‡æ”¹å˜
        function onDeviceChange(e) {
            selectedDeviceId = e.target.value;
            if (selectedDeviceId) {
                startVolumeMonitor();
            }
        }

        // éŸ³é‡ç›‘æ§
        async function startVolumeMonitor() {
            if (volumeMonitorInterval) {
                clearInterval(volumeMonitorInterval);
            }

            if (!selectedDeviceId) return;

            try {
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                }

                stream = await navigator.mediaDevices.getUserMedia({
                    audio: { deviceId: selectedDeviceId }
                });

                const source = audioContext.createMediaStreamSource(stream);
                const analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                source.connect(analyser);

                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);

                volumeMonitorInterval = setInterval(() => {
                    analyser.getByteFrequencyData(dataArray);
                    const average = dataArray.reduce((a, b) => a + b) / bufferLength;
                    const volume = Math.min(100, Math.round((average / 255) * 100 * 2));
                    
                    document.getElementById('volumeFill').style.width = volume + '%';
                    document.getElementById('volumeText').textContent = volume + '%';
                }, 100);
            } catch (error) {
                console.error('éŸ³é‡ç›‘æ§å¤±è´¥:', error);
            }
        }

        // åŠ è½½åºåˆ—
        function loadSequences() {
            const input = document.getElementById('batchInput').value;
            sequences = input.split('\n')
                .map(s => s.trim())
                .filter(s => s && /^\d+$/.test(s));

            if (sequences.length === 0) {
                alert('è¯·è¾“å…¥æœ‰æ•ˆçš„æ•°å­—åºåˆ—');
                return;
            }

            currentIndex = 0;
            updateSequenceList();
            updateProgress();
        }

        // æ›´æ–°åºåˆ—åˆ—è¡¨æ˜¾ç¤º
        function updateSequenceList() {
            const listEl = document.getElementById('sequenceList');
            listEl.innerHTML = '';

            sequences.forEach((seq, index) => {
                const item = document.createElement('div');
                item.className = 'sequence-item';
                
                // æ ¹æ®çŠ¶æ€è®¾ç½®æ ·å¼
                if (index === currentIndex) {
                    item.classList.add('current');
                } else if (localStorage.getItem(`recorded_${seq}`) === 'true') {
                    item.classList.add('completed');
                } else {
                    item.classList.add('pending');
                }

                item.dataset.index = index;
                
                const status = localStorage.getItem(`recorded_${seq}`) === 'true' ? 'âœ…' : 'â³';
                
                item.innerHTML = `
                    <span style="font-size: 20px; font-weight: bold;">${seq}</span>
                    <span class="status">${status}</span>
                `;
                
                item.addEventListener('click', () => selectSequence(index));
                listEl.appendChild(item);
            });

            // æ›´æ–°å½“å‰æ˜¾ç¤º
            if (currentIndex >= 0 && currentIndex < sequences.length) {
                document.getElementById('currentNumber').textContent = sequences[currentIndex];
            } else {
                document.getElementById('currentNumber').textContent = '---';
            }

            // æ»šåŠ¨åˆ°å½“å‰é¡¹
            const currentItem = listEl.querySelector('.current');
            if (currentItem) {
                currentItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        // é€‰æ‹©åºåˆ—
        function selectSequence(index) {
            if (isRecording) {
                alert('è¯·å…ˆåœæ­¢å½“å‰å½•åˆ¶');
                return;
            }

            currentIndex = index;
            updateSequenceList();
            document.getElementById('recordingStatus').textContent = 'ç‚¹å‡»æŒ‰é’®å¼€å§‹å½•åˆ¶';
            document.getElementById('recordingStatus').className = 'recording-status ready';
        }

        // æ›´æ–°è¿›åº¦
        function updateProgress() {
            const completed = sequences.filter(seq => 
                localStorage.getItem(`recorded_${seq}`) === 'true'
            ).length;
            
            const total = sequences.length;
            const progress = total > 0 ? (completed / total) * 100 : 0;
            
            document.getElementById('completedCount').textContent = completed;
            document.getElementById('totalCount').textContent = total;
            document.getElementById('completionRate').textContent = Math.round(progress) + '%';
            
            document.getElementById('progressFill').style.width = progress + '%';
            document.getElementById('progressFill').textContent = `${completed} / ${total}`;
        }

        // å¤„ç†å½•åˆ¶
        async function handleRecord() {
            if (currentIndex < 0 || currentIndex >= sequences.length) {
                alert('è¯·å…ˆé€‰æ‹©è¦å½•åˆ¶çš„åºåˆ—');
                return;
            }

            if (!selectedDeviceId) {
                alert('è¯·å…ˆé€‰æ‹©éº¦å…‹é£è®¾å¤‡');
                return;
            }

            if (isRecording) {
                return;
            }

            // ç¦ç”¨æŒ‰é’®
            document.getElementById('recordBtn').disabled = true;
            document.getElementById('recordBtn').textContent = 'å‡†å¤‡ä¸­...';

            // å€’è®¡æ—¶
            if (config.countdownTime > 0) {
                await countdown(config.countdownTime);
            }

            // å¼€å§‹å½•åˆ¶
            startRecording(sequences[currentIndex]);
        }

        // å€’è®¡æ—¶
        function countdown(seconds) {
            return new Promise(resolve => {
                let remaining = seconds;
                const countdownEl = document.getElementById('countdown');
                const statusEl = document.getElementById('recordingStatus');
                
                countdownEl.classList.remove('hidden');
                countdownEl.textContent = remaining;
                statusEl.textContent = `å‡†å¤‡å½•åˆ¶ï¼Œå€’è®¡æ—¶ ${remaining} ç§’...`;
                statusEl.className = 'recording-status countdown';

                countdownInterval = setInterval(() => {
                    remaining--;
                    if (remaining > 0) {
                        countdownEl.textContent = remaining;
                        statusEl.textContent = `å‡†å¤‡å½•åˆ¶ï¼Œå€’è®¡æ—¶ ${remaining} ç§’...`;
                    } else {
                        clearInterval(countdownInterval);
                        countdownEl.classList.add('hidden');
                        resolve();
                    }
                }, 1000);
            });
        }

        // å¼€å§‹å½•åˆ¶
        async function startRecording(sequence) {
            try {
                // åˆ›å»ºæ–°çš„æµ
                const recordStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        deviceId: selectedDeviceId,
                        sampleRate: config.sampleRate,
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    }
                });

                // åˆ›å»º MediaRecorder
                mediaRecorder = new MediaRecorder(recordStream, {
                    mimeType: 'audio/webm'
                });

                audioChunks = [];
                isRecording = true;
                recordingStartTime = Date.now();

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = async () => {
                    isRecording = false;
                    recordStream.getTracks().forEach(track => track.stop());

                    // å¤„ç†å½•éŸ³
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    await processAndSave(audioBlob, sequence);

                    // æ ‡è®°å®Œæˆ
                    localStorage.setItem(`recorded_${sequence}`, 'true');
                    updateSequenceList();
                    updateProgress();

                    // æ¢å¤UI
                    document.getElementById('recordBtn').disabled = false;
                    document.getElementById('recordBtn').innerHTML = '<span>ğŸ™ï¸</span> å½•åˆ¶å½“å‰åºåˆ—';
                    document.getElementById('recordingStatus').textContent = 'å½•åˆ¶å®Œæˆï¼é€‰æ‹©ä¸‹ä¸€ä¸ªåºåˆ—ç»§ç»­';
                    document.getElementById('recordingStatus').className = 'recording-status ready';
                    document.getElementById('recordingTimer').textContent = 'å‡†å¤‡å°±ç»ª';

                    // è‡ªåŠ¨é€‰æ‹©ä¸‹ä¸€ä¸ªæœªå½•åˆ¶çš„
                    autoSelectNext();
                };

                // å¼€å§‹å½•éŸ³
                mediaRecorder.start();

                // æ›´æ–°UI
                document.getElementById('recordBtn').innerHTML = '<span>ğŸ”´</span> å½•åˆ¶ä¸­...';
                document.getElementById('recordingStatus').textContent = 'æ­£åœ¨å½•åˆ¶ï¼Œè¯·æ•²å‡»é”®ç›˜...';
                document.getElementById('recordingStatus').className = 'recording-status recording';

                // æ›´æ–°è®¡æ—¶å™¨
                recordingInterval = setInterval(() => {
                    const elapsed = (Date.now() - recordingStartTime) / 1000;
                    document.getElementById('recordingTimer').textContent = `å½•åˆ¶ä¸­ï¼š${elapsed.toFixed(1)} / ${config.recordingDuration} ç§’`;
                }, 100);

                // å®æ—¶æ³¢å½¢
                visualizeAudio(recordStream);

                // è‡ªåŠ¨åœæ­¢
                setTimeout(() => {
                    if (isRecording && mediaRecorder.state === 'recording') {
                        clearInterval(recordingInterval);
                        mediaRecorder.stop();
                    }
                }, config.recordingDuration * 1000);

            } catch (error) {
                console.error('å½•éŸ³å¤±è´¥:', error);
                alert('å½•éŸ³å¤±è´¥ï¼š' + error.message);
                
                // æ¢å¤UI
                document.getElementById('recordBtn').disabled = false;
                document.getElementById('recordBtn').innerHTML = '<span>ğŸ™ï¸</span> å½•åˆ¶å½“å‰åºåˆ—';
                document.getElementById('recordingStatus').textContent = 'å½•éŸ³å¤±è´¥ï¼Œè¯·é‡è¯•';
                document.getElementById('recordingStatus').className = 'recording-status ready';
            }
        }

        // è‡ªåŠ¨é€‰æ‹©ä¸‹ä¸€ä¸ªæœªå½•åˆ¶çš„åºåˆ—
        function autoSelectNext() {
            // æŸ¥æ‰¾ä¸‹ä¸€ä¸ªæœªå½•åˆ¶çš„åºåˆ—
            for (let i = currentIndex + 1; i < sequences.length; i++) {
                if (localStorage.getItem(`recorded_${sequences[i]}`) !== 'true') {
                    currentIndex = i;
                    updateSequenceList();
                    return;
                }
            }

            // å¦‚æœåé¢æ²¡æœ‰ï¼Œä»å¤´æŸ¥æ‰¾
            for (let i = 0; i < currentIndex; i++) {
                if (localStorage.getItem(`recorded_${sequences[i]}`) !== 'true') {
                    currentIndex = i;
                    updateSequenceList();
                    return;
                }
            }

            // å¦‚æœå…¨éƒ¨å®Œæˆ
            if (sequences.every(seq => localStorage.getItem(`recorded_${seq}`) === 'true')) {
                alert('æ­å–œï¼æ‰€æœ‰åºåˆ—å½•åˆ¶å®Œæˆï¼');
            }
        }

        // å¤„ç†å¹¶ä¿å­˜å½•éŸ³
        async function processAndSave(blob, sequence) {
            try {
                // è½¬æ¢ä¸ºWAVæ ¼å¼
                const wavBlob = await convertToWav(blob);

                // ä¿å­˜æ–‡ä»¶
                if (directoryHandle) {
                    // ä½¿ç”¨File System Access API
                    await saveToDirectory(wavBlob, `${sequence}.wav`);
                } else {
                    // é™çº§ä¸ºä¸‹è½½
                    downloadFile(wavBlob, `${sequence}.wav`);
                }

                // ç»˜åˆ¶æ³¢å½¢
                await drawWaveform(wavBlob);

            } catch (error) {
                console.error('å¤„ç†å½•éŸ³å¤±è´¥:', error);
                alert('å¤„ç†å½•éŸ³å¤±è´¥ï¼Œè¯·é‡è¯•');
                // ç§»é™¤å·²å®Œæˆæ ‡è®°
                localStorage.removeItem(`recorded_${sequence}`);
            }
        }

        // è½¬æ¢ä¸ºWAVæ ¼å¼
        async function convertToWav(webmBlob) {
            const arrayBuffer = await webmBlob.arrayBuffer();
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

            // è½¬æ¢ä¸ºå•å£°é“
            const numberOfChannels = 1;
            const length = audioBuffer.length;
            const sampleRate = audioBuffer.sampleRate;
            const bitsPerSample = 16;
            const bytesPerSample = bitsPerSample / 8;
            const blockAlign = numberOfChannels * bytesPerSample;
            const byteRate = sampleRate * blockAlign;
            const dataSize = length * blockAlign;
            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);

            // WAVæ–‡ä»¶å¤´
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };

            writeString(0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numberOfChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitsPerSample, true);
            writeString(36, 'data');
            view.setUint32(40, dataSize, true);

            // è·å–éŸ³é¢‘æ•°æ®ï¼ˆæ··åˆå¤šå£°é“ä¸ºå•å£°é“ï¼‰
            let channelData;
            if (audioBuffer.numberOfChannels > 1) {
                channelData = new Float32Array(length);
                for (let i = 0; i < length; i++) {
                    let sum = 0;
                    for (let channel = 0; channel < audioBuffer.numberOfChannels; channel++) {
                        sum += audioBuffer.getChannelData(channel)[i];
                    }
                    channelData[i] = sum / audioBuffer.numberOfChannels;
                }
            } else {
                channelData = audioBuffer.getChannelData(0);
            }

            // å†™å…¥éŸ³é¢‘æ•°æ®
            const offset = 44;
            for (let i = 0; i < length; i++) {
                const sample = Math.max(-1, Math.min(1, channelData[i]));
                const value = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                view.setInt16(offset + i * bytesPerSample, value, true);
            }

            return new Blob([buffer], { type: 'audio/wav' });
        }

        // ä¿å­˜åˆ°ç›®å½•
        async function saveToDirectory(blob, filename) {
            try {
                const fileHandle = await directoryHandle.getFileHandle(filename, { create: true });
                const writable = await fileHandle.createWritable();
                await writable.write(blob);
                await writable.close();
                console.log(`å·²ä¿å­˜: ${filename}`);
            } catch (error) {
                console.error('ä¿å­˜å¤±è´¥:', error);
                // é™çº§ä¸ºä¸‹è½½
                downloadFile(blob, filename);
            }
        }

        // ä¸‹è½½æ–‡ä»¶
        function downloadFile(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        // é€‰æ‹©æ–‡ä»¶å¤¹
        async function selectFolder() {
            if ('showDirectoryPicker' in window) {
                try {
                    directoryHandle = await window.showDirectoryPicker();
                    document.getElementById('folderStatus').classList.remove('hidden', 'error');
                    document.getElementById('folderPath').textContent = `å·²é€‰æ‹©æ–‡ä»¶å¤¹: ${directoryHandle.name}`;
                } catch (error) {
                    console.error('é€‰æ‹©æ–‡ä»¶å¤¹å¤±è´¥:', error);
                }
            } else {
                document.getElementById('folderStatus').classList.remove('hidden');
                document.getElementById('folderStatus').classList.add('error');
                document.getElementById('folderPath').textContent = 'æµè§ˆå™¨ä¸æ”¯æŒæ–‡ä»¶å¤¹é€‰æ‹©ï¼Œå°†é€šè¿‡ä¸‹è½½ä¿å­˜';
            }
        }

        // å¯è§†åŒ–éŸ³é¢‘
        function visualizeAudio(stream) {
            const canvas = document.getElementById('waveform');
            const canvasCtx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            const source = audioContext.createMediaStreamSource(stream);
            const analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048;
            source.connect(analyser);

            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);

            function draw() {
                if (!isRecording) return;

                requestAnimationFrame(draw);

                analyser.getByteTimeDomainData(dataArray);

                canvasCtx.fillStyle = '#f0f0f0';
                canvasCtx.fillRect(0, 0, canvas.width, canvas.height);

                canvasCtx.lineWidth = 2;
                canvasCtx.strokeStyle = '#2196F3';
                canvasCtx.beginPath();

                const sliceWidth = canvas.width / bufferLength;
                let x = 0;

                for (let i = 0; i < bufferLength; i++) {
                    const v = dataArray[i] / 128.0;
                    const y = v * canvas.height / 2;

                    if (i === 0) {
                        canvasCtx.moveTo(x, y);
                    } else {
                        canvasCtx.lineTo(x, y);
                    }

                    x += sliceWidth;
                }

                canvasCtx.lineTo(canvas.width, canvas.height / 2);
                canvasCtx.stroke();
            }

            draw();
        }

        // ç»˜åˆ¶å®Œæ•´æ³¢å½¢
        async function drawWaveform(blob) {
            const arrayBuffer = await blob.arrayBuffer();
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            
            const canvas = document.getElementById('waveform');
            const canvasCtx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            const data = audioBuffer.getChannelData(0);
            const step = Math.ceil(data.length / canvas.width);
            const amp = canvas.height / 2;

            canvasCtx.fillStyle = '#f0f0f0';
            canvasCtx.fillRect(0, 0, canvas.width, canvas.height);

            canvasCtx.strokeStyle = '#4CAF50';
            canvasCtx.lineWidth = 1;

            for (let i = 0; i < canvas.width; i++) {
                let min = 1.0;
                let max = -1.0;

                for (let j = 0; j < step; j++) {
                    const datum = data[(i * step) + j];
                    if (datum < min) min = datum;
                    if (datum > max) max = datum;
                }

                const yLow = (1 + min) * amp;
                const yHigh = (1 + max) * amp;

                canvasCtx.beginPath();
                canvasCtx.moveTo(i, yLow);
                canvasCtx.lineTo(i, yHigh);
                canvasCtx.stroke();
            }
        }

        // æ›´æ–°é…ç½®
        function updateConfig() {
            config.countdownTime = parseInt(document.getElementById('countdownTime').value);
            config.recordingDuration = parseInt(document.getElementById('recordingDuration').value);
            
            // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
            localStorage.setItem('recorderConfig', JSON.stringify(config));
        }

        // åŠ è½½é…ç½®
        function loadConfig() {
            const saved = localStorage.getItem('recorderConfig');
            if (saved) {
                const savedConfig = JSON.parse(saved);
                Object.assign(config, savedConfig);
                
                document.getElementById('countdownTime').value = config.countdownTime;
                document.getElementById('recordingDuration').value = config.recordingDuration;
            }
        }

        // å¿«æ·é”®å¤„ç†
        function handleKeyPress(e) {
            if (isRecording) return;

            switch(e.key) {
                case 'Enter':
                    e.preventDefault();
                    if (!document.getElementById('recordBtn').disabled) {
                        handleRecord();
                    }
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    if (currentIndex < sequences.length - 1) {
                        selectSequence(currentIndex + 1);
                    }
                    break;
                case 'ArrowUp':
                    e.preventDefault();
                    if (currentIndex > 0) {
                        selectSequence(currentIndex - 1);
                    }
                    break;
                case 'r':
                case 'R':
                    e.preventDefault();
                    if (currentIndex >= 0 && currentIndex < sequences.length) {
                        // æ¸…é™¤å½“å‰åºåˆ—çš„å·²å½•åˆ¶çŠ¶æ€
                        localStorage.removeItem(`recorded_${sequences[currentIndex]}`);
                        updateSequenceList();
                        updateProgress();
                    }
                    break;
            }
        }
    </script>
</body>
</html>